# 锁

### 产生

线程安全：多线程程序运行的最终结果与预期一致，就是线程安全，否则就是线程不安全；保证线程安全的条件：

- 不跨线程共享变量，线程共享的变量改为方法局部变量
- 使状态变量为不可变的，使用final修饰（将变量变为常量）
- 在任何访问状态变量时需要同步，使用synchronized修饰方法或同步代码块
- 每个共享的可变变量都需要由一个确定的锁保护，使用Lock锁

锁：是一种保护机制，在多线程条件下，保证数据操作的一致性

### 分类

> 锁的分类包括：悲观锁、乐观锁、可重入锁、自旋锁、独享锁、读写锁、阻塞锁、公平锁、非公平锁、分段锁、对象锁、类锁、轻量级锁、分布式锁等。

- 悲观锁：对外界的修改持保守态度，在整个数据处理过程中，将数据处于锁定状态，适用于”读多写少“的场景

- 乐观锁：跟悲观锁相反，假设数据一般情况下不会造成冲突，只有在数据进行提交更新时，才会正式对数据的冲突与否进行检测，如果冲突了，则返回错误信息，让用户决定如何去做，一共分为三个阶段：

  - 数据读取
  - 写入校验
  - 数据写入

  乐观锁适用于读多写少的场景，可以提高系统的并发量，java中乐观锁的基础CAS

- 可重入锁：也叫递归锁，是指同一个线程在调用外层方法获取锁的时候，再进入内层会自动获取锁，ReentrantLock和synchronized都是可重入锁。可重入锁的优点：一定程度上避免死锁

- 自旋锁：是采用让当前线程不停地在循环体内执行，当循环的条件被其他线程改变时才能进入临界区，自旋锁只是将当前线程不停地执行循环体，不改变线程状态的改变，所以相应速度更快，但当线程数不断增加时，性能下降明显，因为每个线程都需执行，会占用CPU时间片。如果线程竞争不激烈，并且保持锁的时间段，适合使用自旋锁

- 独享锁：是指该锁一次只能被一个线程持有，ReentrantLock和synchronized都是独享锁

- 共享锁：该锁可以被多个线程所持有

  - ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁
  - 读锁的共享锁可保证并发读是非常高效的，读写、写读、写写的过程是互斥的
  - 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享

- 互斥锁、读写锁：独享锁、共享锁是一种广义上的说法，而互斥锁、读写锁指具体的实现，在java中：

  - 互斥锁的实现：ReentrantLock
  - 读写锁的实现：ReentrantReadWriteLock

- 阻塞锁：可以说让线程进入阻塞状态进行等待，当获得相应的信号（唤醒、时间）时，才可以进入线程的准备就绪状态

  - 准备就绪状态的所有线程，通过竞争，进入运行状态
  - 在java中，能够进入/退出、阻塞状态或者包含阻塞锁的方法有：
    - synchronized关键字，重量锁
    - ReentrantLock
    - Object.wait()/notify()
    - LockSupport.park()/unpack()

- 公平锁：指多个线程按照申请锁的顺序来获取锁

- 非公平锁：多个线程获取的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程先获取锁

  - 可能造成优先级反转或者线程饥饿
  - java的ReentrantLock可以通过构造函数ReentrantLock(boolean fair)来指定该锁是否是公平锁，默认是非公平锁；非公平锁的优点在于吞吐量比公平锁大
  - java的synchronized也是一种非公平锁

- 分段锁：其实是一种锁的设计，目的是细化锁的粒度，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作

  - ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）
  - 当需要put元素的时候，并不是对整个HashMap加锁，而是先通过hashcode知道要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put时，只要不是放在同一个分段中，可支持并行插入

- 对象锁：一个线程可以多次对同一个对象上锁

  - 对于每一个对象，java虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加一，每释放一次，计数器就减一，当计数器为0时，锁就被完全释放了
  - 在java程序中，只需要使用synchronized块或者synchronized方法就可以标志一个监视区域。每当进入一个监视区域时，java虚拟机都会自动锁上对象或类
  - synchronized修饰非静态方法、同步代码块的synchronized(this)、synchronized(非this对象)，锁的是对象，线程想要执行对应的同步代码块，需要获得对象锁

- 类锁：synchronized修饰的静态方法或者同步代码块的synchronized(类.class)，线程想要执行相应的同步代码，需要获得类锁

- 分布式锁：分布式集群中，对锁接口QPS性能要求很高，单台服务器满足不了要求，可以考虑将锁服务部署在独立的分布式系统中，比如借助分布式缓存来实现。工作中分布式锁可以使用Redis或者Zookeeper

  - QPS：单位时间内的请求数

    计算QPS的方式：

    1. 接口日志埋点
    2. tomcat、nginx的访问日志access.log（常用）

    多台服务器，计算QPS时需要注意负载均衡策略，常见的负载均衡策略：

    - 随机轮询
    - 权重：weight
    - 根据URL取Hash，所有访问某个URL指向同一台服务器，WEB服务端缓存（不是Redis）304
    - 根据IP（客户端访问IP）取Hash值，优点，Session
    - 响应优先

- 注意事项：

  - AQS：AbstractQueuedSynchronizer，提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现模板方法，然后将子类作为同步组件的内部类

### 悲观锁与乐观锁

在mysql中：

- 悲观锁有表锁、行锁，还有间隙锁和读锁，这些锁在被触发时都会引起线程阻塞
- 乐观锁，在mysql中本身不存在，通过MVCC（多版本控制Multi-Version Concurrency Control）的机制支持乐观锁

