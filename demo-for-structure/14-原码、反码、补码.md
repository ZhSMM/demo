### 原码、反码、补码

机器数和真值：

- 机器数：一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1
- 真值：因为第一位是符号位，所以机器数的形式值就不等于真正的数值，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值

原码、反码和补码：

- 原码：符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。8位二进制的取值范围：[-128,127]

  ```
  [+1]原 = 0000 0001
  [-1]原 = 1000 0001
  ```

- 反码：

  - 正数：正数的反码是其本身
  - 负数：在原码的基础上，符号位不变，其余位取反

- 补码：

  - 正数：正数的补码是其本身
  - 负数：负数的补码是在原码的基础上，符号位不变，其余各位取反，然后加1

补码存在的意义：

- 解决 0 的符号问题：
  - 0b0000 0000：0
  - 0b1000 0000：-128
- 利用补码，可以使符号位参与运算，用加法代替减法，降低运算复杂度

数学原理：

- 同余：两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余。记作 a ≡ b (mod m)

- 负数取模：x mod y等于 x 减去 y 乘上 x与y的商的下界

- 同余数的反身性：a ≡ a (mod m)

- 线性运算定理：

  >  如果a ≡ b (mod m)，c ≡ d (mod m) 那么： 
  >
  > - a ± c ≡ b ± d (mod m)
  > - a * c ≡ b * d (mod m)

补码的溢出：

- 8 bit 的 byte 类型的表示范围为：

  > [-128, 127]
  >
  > 0 = [0000 0000]（补）
  >
  > -128 = [1000 0000]（补）
  >
  > 127 = [0111 1111]（补）

- 当 byte 类型的变量超上限 127 时，如：

  >+128 = -（-128）= 127 + 1
  >= [1111 1111]（补）+ [0000 0001]（补）
  >= [1000 0000]（补）
  >= -128
  >
  >+129 = 127 + 2
  >= [1111 1111]（补）+ [0000 0001]（补）
  >= [1000 0001]（补）
  >= [1111 1111]（原）
  >= -127

- 当byte类型的变量超过下限-128时：

  > -129 = -128 - 1
  > = [1000 0000]（补) - [0000 0001]（补）
  > = [0111 1111]（补）
  > = 127
  >
  > -130 = -128 - 2
  > = [1000 0000]（补) - [0000 0010]（补）
  > = [0111 1110]（补）
  > = 126

大数溢出问题：

> int类型在32位系统中占4个字节、32bit，补码表示的的数据范围为：
>
> - `[10000000 00000000 00000000 00000000] ~ [01111111 11111111 11111111 11111111]`
> - `[-2147483648, 2147483647]`
>
> 在java中表示为：`[Integer.MIN_VALUE, Integer.MAX_VALUE]`
>
> - 对下限取相反数超过上限：`Integer.MIN_VALUE == -Integer.MIN_VALUE`

### Java位运算

- 与运算`&`：两个操作数中位都为 1，结果才为 1，否则结果为 0

- 或运算`|`：两个位只要有一个为 1，那么结果就是 1，否则就为 0

- 按位取反运算`~`：如果位为 0，结果是 1，如果位为 1，结果是 0
  - 负数n：`-n = ~n+1`
  - 正数n：`-n = ~(n-1)`
  - 0：`-1 = ~0`
  
- 异或运算`^`：两个操作数的位中，相同则结果为0，不同则结果为1

- 向左位移`<<`：二进制向左移位

- 向右位移`>>`：二进制向右位移，高位填充符号位

- 无符号向右位移`>>>`：忽略符号位，二进制向右位移，空位都以 0 补齐，在 java 中，byte,short,int,char类型得数据在进行无符号右移时是先将数据类型强制转化成int型，再进行移位操作

  ```java
  int a=0b10000000000000000000000000000010;
  int b=a<<1;
  int bb=0b00000000000000000000000000000100; // 符号位消失
  int c=a>>1;
  int cc=0b11000000000000000000000000000001; // 符号位移动，高位填充符号位
  int d=a>>>1;
  int dd=0b01000000000000000000000000000001; // 符号位填充0
  System.out.println(b==bb); // true
  System.out.println(c==cc); // true
  System.out.println(d==dd); // true
  
  // 二进制形式输出
  int a=0b10000000000000000000000000000010;
  int b=a>>1;
  String s=Integer.toBinaryString(b);
  System.out.println("s = " + s);
  // 输出：s = 11000000000000000000000000000001
  ```
